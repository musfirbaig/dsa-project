import json
import os
import sys
import time
from nltk.stem import PorterStemmer
from constants import STOP_WORDS
import ujson

STOP_WORDS_SET = set(STOP_WORDS)
stemmerPort = PorterStemmer()
# this hashing function was written by me specifically for nela-gt-2022 dataset,
# it sufficiently (uniformaly) distributes words in the search engine barrels 
class Hashing:
    def HasherFunction(self, inputString):
        sum = 0
        for index, element in enumerate(inputString):
            sum = sum + (len(inputString) - index)*ord(element)
        return (sum)%500
    
# class written to generate forward index 
class ForwardIndex:

    def convertToWords(self, content):
        """
        INPUT: article content
        OUTPUT: list of words for case insensitivity (lowercase)
        """
        words = content.lower().split(' ')
        words = [stemmerPort.stem(word).strip(',._+/\\!@#$?^()[]}{"').strip() for word in words if len(word) and word not in STOP_WORDS_SET]
        return words


    def dictWordToPositionAndFrequency(self, words):
        """
        INPUT: list of words and docID,
        OUTPUT: Hash Map of objects containing word-> freq and docID-> docID
        """
        wordsObject = {}
        for index, word in enumerate(words):
            if word in wordsObject:
                wordsObject[word]["freq"] += 1
                wordsObject[word]["pos"].append(index)
            else:
                wordsObject[word] = {
                    "freq" : 1,
                    "pos" : [index]
                }
        return wordsObject


    def createForwardIndex(self, documentList):
        """
        INPUT: A list of .json files in a directory
        OUTPUT: The Corresponding Forward Index
        """
        start_time = time.time()
        forwardIndex = []
        keysOfArticle = list(documentList[0][0].keys())
        keysOfArticle.remove("content")
        for jsonDocument in documentList:
            for article in jsonDocument:
                articleObject = {"metaData": {}}
                words = self.convertToWords(article["content"])
                wordsObject = self.dictWordToPositionAndFrequency(words)
                articleObject["words"] = wordsObject
                for key in keysOfArticle:
                    articleObject["metaData"][key] = article[key]
                forwardIndex.append(articleObject)
        print("Execution Time (Forward): " + str(time.time()-start_time))
        return forwardIndex
    
    def documentList(self, directoryName):
        """
        INPUT: Directory to operate on
        OUTPUT: List of files in directory
        """
        files = os.listdir(directoryName)
        files = [(directoryName+"/"+f) for f in files if os.path.isfile(directoryName+'/'+f)]
        listDr = []
        for file in files:
            with open(file) as f:
                listDr.append(ujson.load(f))
        return listDr


    def forwardIndexGenerator(self, directoryName):
        """
        INPUT: Directory to operate on
        OUTPUT: Corresponding Forward Index
        """
        documentList = self.documentList(directoryName)
        forwardIndex = self.createForwardIndex(documentList)    
        self.writeForwardIndexToFile(forwardIndex)

    def writeForwardIndexToFile(self, forwardIndex):
        """
        INPUT: Forward Index
        SIDE EFFECTS: Dumping Forward Index to File
        """
        file_path = "Forward_Index.json"
        with open(file_path, 'w') as json_file:
            ujson.dump(forwardIndex, json_file)

# class operates on the ForwardIndex generated by the previous class and generates
# barrel based inverted index
class InvertedIndex:
    
    def generateInvertedIndex(self):
        """
        SIDE EFFECTS: generates a inverted index for the
        forward index present in the directory
        """
        hashingObject = Hashing()
        startTime = time.time()

        with open("Forward_Index.json", "r") as forwardIndexFile:
            forwardIndex = ujson.load(forwardIndexFile)
        invertedIndex = {}

        for articleData in forwardIndex:
            words = articleData["words"].keys()
            for word in words:
                barrelName = hashingObject.HasherFunction(word)
                wordObjectInfo = articleData["words"][word]
                articleId = articleData["metaData"]["id"]
                wordObjectInfo["id"] = articleId
                if barrelName in invertedIndex:
                    if word in invertedIndex[barrelName]:
                        invertedIndex[barrelName][word].append(wordObjectInfo)
                    else:
                        invertedIndex[barrelName][word] = [wordObjectInfo]
                else:
                    invertedIndex[barrelName] = {word: [wordObjectInfo]}
        print("Execution Time (Inverted Process): " + str(time.time() - startTime))
        startTime = time.time()
        barrelNames = invertedIndex.keys()
        forwardIndex = []
        os.makedirs("Inverted_Index", exist_ok=True)
        for barrelName in barrelNames:
            barrelFilePath = "Inverted_Index/" + "barrel" + str(barrelName) + ".json"
            with open(barrelFilePath, mode="w") as barrel:
                ujson.dump(invertedIndex[barrelName], barrel)
        print("Execution Time (Inverted Writing Barrels): " + str(time.time() - startTime))


# class demonstrating the generation of forward index as well as
# the inverted index
class IndexGenerator:

    def runGenerator(self, directoryName):
        """
        SIDE EFFECT: Creation of forward and inverted indexes
        """
        fIndex = ForwardIndex()
        iIndex = InvertedIndex()
        fIndex.forwardIndexGenerator(directoryName)
        iIndex.generateInvertedIndex()


def __main__():
    #  usage: python IndexGen.py <directory>
    if (len(sys.argv) != 2):
        print("Correct Usage: \"python IndexGen.py <directory>\"")
        sys.exit()
    directoryName = sys.argv[1]
    indexGenerator = IndexGenerator()
    indexGenerator.runGenerator(directoryName)

__main__()
